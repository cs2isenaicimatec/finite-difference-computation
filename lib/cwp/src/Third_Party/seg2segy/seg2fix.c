/* small program to fix Summit's wrong SEG-2 output files *//* works in-place to preserve disk space                  *//* author: Steffen Grunewald (sg), formerly at GFZ Potsdam, Germany *//* version 	0.10	950126	sg	first try		0.20	950126	sg	usable version		0.25	950126	sg	public release		0.26	950127	sg	free() fix*/#include <stdio.h>#include <malloc.h>#define	VERSION	"0.26"#define	uchar	unsigned char#define ushort	unsigned short#define	ulong	unsigned long#define	bool	int#ifndef	SEEK_SET#define	SEEK_SET	0#endifstruct { char	length; char	*string;} filters[] ={ {12,"ALIAS_FILTER"}, {15,"HIGH_CUT_FILTER"}, {14,"LOW_CUT_FILTER"}, {0,NULL}};voidmyswap(uchar * from, uchar * to, int nbytes){uchar * q; for (q=to+nbytes-1; q>=to; *q--=*from++);}ushorttoushort(uchar *p, bool isintel){ static ushort r;#ifdef i386		memcpy((uchar *)&r,p,sizeof(ushort));#else#ifdef sparc		myswap(p,(uchar *)&r,sizeof(ushort));#else#error unsupported processor type#endif#endif		return(r);}ulongtoulong(uchar *p, bool isintel){ static ulong r;#ifdef i386		memcpy((uchar *)&r,p,sizeof(ulong));#else#ifdef sparc		myswap(p,(uchar *)&r,sizeof(ulong));#else#error unsupported processor type#endif#endif		return(r);}intmain(int argc,char **argv){ FILE	*seg; bool	isintel; uchar	fdb1[32];	/* first part of file descriptor block */ ushort	tpssize;	/* trace pointer subblock size */ uchar	*tpsptr;	/* area for tps processing */ ulong	*trcptr;	/* fseek values for traces */ uchar	tdb1[32];	/* first part of trace descriptor block */ ushort	tdbsize; uchar	*tdbptr;	/* area for tdb processing */ uchar	*tdbptr2;	/* ------- " ------------- */ ushort	tracenum;	/* number of traces */ ushort	traceindex;	/* trace index */ ulong	samplenum;	/* number of samples */ ulong	datasize;	/* computed data size */ ulong	d;		/* ??? */ ushort	filterindex; long	valcount; char	dummy[1024]; float	freq,slope; uchar  *p,*q; ushort	skip; bool   needrewrite; fprintf(stderr,"%s: version %s starting.\n",		argv[0],VERSION);  seg=fopen(argv[1],"r+b"); if (!seg) {  fprintf(stderr,"%s: cannot open %s for read/write.\n",		argv[0],argv[1]);  exit(1); } fprintf(stderr,"%s: fixing data file %s.\n",		argv[0],argv[1]); if (fread(fdb1,1,32,seg) != 32) {  fprintf(stderr,"%s: cannot read 1st part of file descriptor block.\n",		argv[0]);  exit(1); } if (!(	((fdb1[0]==0x3a)&&(fdb1[1]==0x55)) ||	((fdb1[0]==0x55)&&(fdb1[1]==0x3a)) )) {  fprintf(stderr,"%s: wrong magic number %02x%02x.\n",		argv[0],fdb1[0],fdb1[1]);  exit(1); } isintel=(fdb1[0] == 0x55); fprintf(stderr,"%s: data recorded by %s machine.\n",		argv[0],isintel?"Intel":"Motorola"); tpssize=toushort(&fdb1[4],isintel); tracenum=toushort(&fdb1[6],isintel); if (tpssize != sizeof(void *)*tracenum) {  fprintf(stderr,"%s: wrong values for trace count and pointer table.\n",		argv[0]);  exit(1); } tpsptr=(uchar *)malloc(tpssize); trcptr=(ulong *)malloc(tpssize); if (!tpsptr || !trcptr) {  fprintf(stderr,"%s: not enough memory for trace pointers.\n",		argv[0]);  exit(1); } if(fread(tpsptr,1,tpssize,seg)!=tpssize) {  fprintf(stderr,"%s: cannot read in trace pointer table.\n",		argv[0]);  exit(1); } for (traceindex=0;traceindex<tracenum;traceindex++) {  trcptr[traceindex]=toulong(&tpsptr[4*traceindex],isintel); } free(tpsptr); fprintf(stderr,"%s: %d data traces to fix.\n",		argv[0],tracenum);/* now process all traces */ for (traceindex=0;traceindex<tracenum;traceindex++) {  fseek(seg,trcptr[traceindex],SEEK_SET);  if (fread(tdb1,1,32,seg)!=32)  {   fprintf(stderr,"%s: cannot read 1st part of trace %d desc block .\n",		argv[0],traceindex+1);   exit(1);  }  if (!(	((tdb1[0]==0x22)&&(tdb1[1]==0x44)&&isintel) ||		((tdb1[0]==0x44)&&(tdb1[1]==0x22)&&!isintel) ))  {   fprintf(stderr,"%s: trace %d has wrong magic number %02x%02x.\n",		argv[0],traceindex+1,tdb1[0],tdb1[1]);   exit(1);  }  samplenum=toulong(&tdb1[8],isintel);  switch (tdb1[12])  {   case 1:	datasize=((samplenum+1)/2)*4;		break;   case 2:   case 4:	datasize=samplenum*4;		break;   case 5:	datasize=samplenum*8;		break;   case 3:	datasize=((samplenum+7)/8)*20;		break;  }  d=toulong(&tdb1[4],isintel);  fprintf(stderr,"%s: trace %d has data block length %ld.",		argv[0],traceindex+1,d);  if (d!=datasize)  {   fprintf(stderr," Should be %d.",datasize);   d=toulong((uchar *)&datasize,isintel);   fseek(seg,trcptr[traceindex]+4,SEEK_SET);   if (fwrite(&d,1,4,seg)!=4)   {    fprintf(stderr,"\n%s: error writing correct data size.\n",		argv[0]);    exit(1);   }   fprintf(stderr," Fixed.");  } /* data size to be fixed */  else  {   fprintf(stderr," Ok.");  }  fprintf(stderr,"\n");/* now fix filters */  tdbsize=toushort(&tdb1[2],isintel);  tdbptr=(uchar *)malloc(tdbsize);  tdbptr2=(uchar *)malloc(tdbsize);  needrewrite=0;  if (!tdbptr || !tdbptr2)  {   fprintf(stderr,"%s: not enough memory for trace %d descriptor block.\n",		argv[0],traceindex+1);   exit(1);  }  fseek(seg,trcptr[traceindex],SEEK_SET);  if (fread(tdbptr,1,tdbsize,seg)!=tdbsize)  {   fprintf(stderr,"%s: cannot read in trace %d descriptor block.\n",		argv[0],traceindex+1);   exit(1);  }  for (filterindex=0;filters[filterindex].length!=0;filterindex++)  {   for (p=tdbptr;p<tdbptr+tdbsize-filters[filterindex].length;p++)    if (!strncmp(p,filters[filterindex].string,filters[filterindex].length))     break;   if (!strncmp(p,filters[filterindex].string,filters[filterindex].length))   {    valcount=sscanf(p,"%s%f%f",dummy,&freq,&slope);    if (freq==0.0)     if (valcount==2)     {/* slope is missing, p points to string */      fprintf(stderr,"%s: trace %d has no slope for %s.",		argv[0],traceindex+1,p);      memcpy(tdbptr2,tdbptr,p-tdbptr);		/* copy previous entries */      q=tdbptr2+(p-tdbptr);      skip=toushort(p-sizeof(ushort),isintel);	/* distance to next */      if (skip != (strlen(p)+3))      {       fprintf(stderr,"%s: wrong displacement found for trace %d.\n",		argv[0],traceindex+1);       exit(1);      }      if (tdbptr[tdbsize-1] || tdbptr[tdbsize-2] || tdbptr[tdbsize-3])      {       fprintf(stderr," No space to fix.\n");      }      else      {       skip+=2;					/* add 2 for _6 */       skip=toushort((uchar *)&skip,isintel);	/* new length */       memcpy(q-sizeof(ushort),&skip,sizeof(ushort));						/* insert new length */       memcpy(q,p,strlen(p));	/* append string */       q+=strlen(p);       p+=strlen(p);       *q++=' ';       *q++='6';       for (;p<tdbptr+tdbsize;*q++=*p++);	/* copy remainder */       memcpy(tdbptr,tdbptr2,tdbsize);		/* write back */             fprintf(stderr," Fixed.\n");       needrewrite=1;      } /* space to fix */     } /* value count */   } /* filter found */  } /* for all filters */  if (needrewrite)  {   fseek(seg,trcptr[traceindex],SEEK_SET);   if (fwrite(tdbptr,1,tdbsize,seg)!=tdbsize)   {    fprintf(stderr,"\n%s: error writing fixed trace %d descriptor block.\n",		argv[0],traceindex+1);    exit(1);   }  } /* needrewrite */  free(tdbptr);  free(tdbptr2); } /* all traces */ fclose(seg); fprintf(stderr,"%s: fix of data file %s complete.\n\n",		argv[0],argv[1]);}